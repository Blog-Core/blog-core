var api = require('../api');
var message = require('../message');
var validate = require('../validate');
var languages = require('../languages');

// Creates post view model for already
// existing post or a new post. For new
// post, data must be unset. The authors
// argument must contain the list of all
// users.

exports.create = function(userInfo, type, types, authors, data) {

    var post = {

        $id: ko.observable(),

        // List of authors. Used by the
        // author list dropdown.

        authors: authors,

        // The post title. When this is
        // the new post then initial slug
        // is generated by it.

        title: ko.observable('Untitled').trimmed(),

        // The post slug. Can contain
        // "safe" characters only.

        slug: ko.observable('untitled').trimmed(),

        // The post description. Can
        // be left blank.

        description: ko.observable('').trimmed(),

        // The post content. Can be either
        // Markdown or raw HTML.

        content: ko.observable('').trimmed(),

        types: types,

        // The post type. Currently
        // available types are post,
        // page and block.

        type: ko.observable(type),

        // Type of the post content.
        // Will be processed by the
        // Markdown formatter when set
        // to 'markdown''

        content_type: ko.observable('markdown'),

        // Flag to set whether the post
        // is published or not.

        published: ko.observable(false),

        // Flag to set whether commenting
        // is allowed or not.

        commenting: ko.observable(true),

        // List of tags. Tags are separated
        // by commas.

        tags: ko.observable('').trimmed(),

        // The count of comments.
        // Currently not used.

        comments: ko.observable(0),


        // Selected user. Only admins
        // can select author other than
        // themself.

        author: ko.observable(),

        // Publish date as a string in
        // the format YYYY-MM-DD. Might be
        // unset when published flag is not set.

        date: ko.observable('').trimmed(),

        // Update date as a string in
        // the format YYYY-MM-DD.

        update: ko.observable('').trimmed(),

        // Validates the post data.
        // Saves or updates it using the API.

        submit: function() {

            submitPost(post, true);
        },

        // Similar to submit but leaves
        // the form.

        save: function() {

            submitPost(post, false);
        },

        // The post language code. See
        // languages.js for the list of codes.

        language: ko.observable(bcLanguage),

        // List of available languages.

        languages: languages,

        // Indicator for files component.

        slug_changed: ko.observable(false),

        // Only admin can change the type.

        can_change_type: userInfo.type === 'admin',

        // Only admin can change the author.

        can_change_author: userInfo.type === 'admin',

        // Returns the plain data object
        // to send to the backend.

        toJS: function() {

            var tags = post.tags().trim();

            var date = post.date();

            // date_published will be undefined when
            // no date has been entered.

            var date_published;

            if (date !== '') {

                date_published = isoDateToUnix(date);
            }

            var date_updated = isoDateToUnix(post.update());

            return {

                author: post.author(),
                title: post.title(),
                slug: post.slug(),
                description: post.description(),
                content: post.content(),
                type: post.type(),
                date_published: date_published,
                date_updated: date_updated,
                commenting: post.commenting(),
                published: post.published(),
                content_type: post.content_type(),
                tags: tags === '' ? [] : tags.split(/\, */),
                language: post.language()
            };
        }
    };

    var typeInfo;

    types.forEach(function(info) {

        if (info.name === type) {

            typeInfo = info;
        }
    });

    if (!typeInfo) {

        throw new Error('Invalid type ' + type);
    }

    // Sets the view model values by the
    // actual data object.

    if (data) {

        // When the publish date is set then
        // set the date field to formatted string.

        if (typeof data.date_published !== 'undefined') {

            var d = new Date(data.date_published * 1000);

            post.date(d.toISOString().substring(0, 10));
        }

        post.$id(data.$id);
        post.author(data.author);
        post.title(data.title);
        post.slug(data.slug);
        post.description(data.description || '');
        post.content(data.content);
        post.type(data.type);
        post.content_type(data.content_type);
        post.published(data.published);
        post.commenting(data.commenting);
        post.tags(data.tags.join(', '));
        post.comments(data.comments);
        post.language(data.language);

    } else {

        // Only when for new post.
        // Add automatic slug generation.

        post.title.subscribe(function(value) {

            post.slug(getSlug(value));
        });

        // Select user as post author.

        post.author(userInfo.$id);

        // Default publish date.

        post.date(new Date().toISOString().substring(0, 10));
    }

    // Set publishing permission flag.

    post.can_publish = false;

    if (userInfo.type === 'admin') {

        post.can_publish = true;
    }

    if (typeInfo.grants.indexOf('publish_any') >= 0) {

        post.can_publish = true;
    }

    if (typeInfo.grants.indexOf('publish_own') >= 0) {

        if (post.author() === userInfo.$id) {

            post.can_publish = true;
        }
    }

    // Sets file management flag.

    post.can_manage_files = false;

    if (userInfo.type === 'admin') {

        post.can_manage_files = true;
    }

    if (typeInfo.grants.indexOf('update_any') >= 0) {

        if (typeInfo.grants.indexOf('files') >= 0) {

            post.can_manage_files = true;
        }
    }

    if (typeInfo.grants.indexOf('update_own') >= 0) {

        if (post.author() === userInfo.$id) {

            if (typeInfo.grants.indexOf('files') >= 0) {

                post.can_manage_files = true;
            }
        }
    }

    // Default update date is the current date.

    post.update(new Date().toISOString().substring(0, 10));

    post.published.subscribe(function(value) {

        // Set publish date when post is published.
        // Applies only when no publish date is set.

        if (value && post.date() === '') {

            post.date(new Date().toISOString().substring(0, 10));
        }
    });

    // Indicated that slug has been changed
    // and file management does not work before
    // saving.

    post.slug.subscribe(function(value) {

        post.slug_changed(true);
    });

    return post;
};

// Converts ISO8601 date part into
// an Unix timestamp.

function isoDateToUnix(string) {

    var match = string.match(/^(\d{4})\-(\d{2})\-(\d{2})$/);

    if (!match) {

        throw new Error('Date does not match pattern: ' + string);
    }

    var date = new Date();

    date.setUTCHours(0, 0, 0, 0);
    date.setUTCFullYear(parseInt(match[1], 10), parseInt(match[2], 10) - 1, parseInt(match[3], 10));

    return Math.floor(date.getTime() / 1000);
}

// Validates the given post.
// Adds errors using the validate module.

function validatePost(post) {

    if (post.title() === '') {

        validate.error('post-title', 'Title is not entered.');
    }

    var slug = post.slug();

    if (slug === '') {

        validate.error('post-slug', 'Slug is not entered.');

    } else {

        if (!slug.match(/^[a-z0-9\-_]+$/)) {

            validate.error('post-slug', 'Use lowercase letters, numbers, hyphen and underscore.');
        }
    }

    if (post.content() === '') {

        validate.error('post-content', 'Content is not entered.');
    }

    var date = post.date();

    if (date === '') {

        if (post.published()) {

            validate.error('post-date', 'Publish date is not entered.');
        }

    } else if (!date.match(/^\d{4}\-\d{2}\-\d{2}$/)) {

        validate.error('post-date', 'Date must be in the YYYY-MM-DD format.');
    }

    var update = post.update();

    if (update === '') {

        validate.error('post-update', 'Update date is not entered.');

    } else if (!update.match(/^\d{4}\-\d{2}\-\d{2}$/)) {

        validate.error('post-update', 'Update date must be in the YYYY-MM-DD format.');
    }
}

// Handles save and
// save-with-continue actions.

function submitPost(post, edit) {

    var form = document.getElementById('post');

    validate.clear(form);

    validatePost(post);

    if (validate.hasError(form)) {

        return false;
    }

    // When post has '$id' property
    // then it's an existing post.

    if (post.$id()) {

        updatePost(form, post, edit);

    } else {

        savePost(form, post, edit);
    }
}

// Updates the already existing
// post. Assumes that the post
// is validated.

function updatePost(form, post, edit) {

    api.updatePost(post.$id(), post.toJS()).then(function() {

        message.info('The entry "' + post.title() + '" has been updated.');

        if (edit) {

            post.slug_changed(false);

        } else {

            route.go('entries/' + post.type());
        }

    }).catch(function(err) {

        validate.formError(form, err);

        window.scroll(0, 0);

    });
}

// Saves the new post.

function savePost(form, post, edit) {

    api.savePost(post.toJS()).then(function(res) {

        message.info('The entry "' + post.title() + '" has been saved.');

        // Redirect to post page when we
        // want to keep editing the post.
        // Otherwise go back to listing page.

        if (edit) {

            route.go('entry/' + post.type() + '/' + res);

        } else {

            route.go('entries/' + post.type());
        }

    }).catch(function(err) {

        validate.formError(form, err);

        window.scroll(0, 0);

    });
}
